Task design and breakdown - list deliverables, then break them down as much as possible.
Write code.
Do experiments to analyse its performance.
Write group report - describes design & implementation, and presents results of experiments.
Contribution questionnaire.

Equations - discrete versions we can use will be given?
Indexing is by column, then by row, from the bottom-left.


Tasks with breakdown:

Set up version control:
	▪	Github, users, permissions
	▪	Git ignore file
	▪	Rules - only buildable, working, tested, commented code goes in, everyone updates every day, commit every day, make commits atomic, if you break it you fix it straight away, etc.

Build system:
	▪	Point is to turn the repository into the binary in one easy step.
	▪	Compiler options - all warnings, warnings as errors.
	▪	(Polish) Separate directories with recursive makefiles and intermediate libraries built.
	▪	Build-from-clean tests so we know the prof can build it.
	▪	Top-level make all should build everything and run tests - encourages everyone to test every time they build.  Make check should be a top-level target that just runs the binary.

Test framework:
	▪	UnitTest++ - using a test framework is okay.
	▪	Directory structure - app, test, classes, doc, with classes built into a library which app and tests link in.
	▪	Add UnitTest++ to source tree and build system.
	▪	Test every public function on every class.
	▪	Into makefiles as "make check".
	▪	Test everything with 2Kx2K landscapes plus halo.
	▪	Performance testing - timing with UnitTest++?

"Computational kernel":
	▪	Equations in handout implemented in code - "discrete versions will be given?"
	▪	Class to represent the state of the landscape.
	▪	Class to represent a single grid cell.
	▪	Water cells with 0 populations.
	▪	Halo of cells with 0 - make them water.
	▪	Run sim from t=0 to t=500.

I/O:
	▪	Initial landscape - text file with dimensions and land/water mask.
	▪	Initial distribution for Hares and Pumas: both even distributed, hares even pumas on 			random spots. Polish: Random spots of pumas with gaussian distribution of setable 			variance.
	▪	Inversions! - landscape is indexed from bottom up.
	▪	Appendices A & B have bits on generating your own land/water files.
	▪	Subsequent steps as PPM image files.
	▪	(Polish) Ability to store initial populations in a file and load it - then set any pops in water to zero and issue a warning.
	▪	(Polish) Config file for parameters.
	▪	(Polish) Initial distribution of pumas - "large group of pumas are placed in a confined area, with a uniform distribution of hares."
	▪	(Polish) Random initial config.

Performance tests:
	▪	Choose a simple method for timing - doesn't matter what - so all runs are handled the same way.
	▪	Always print the time taken by each run.
	▪	Optimisation compiler flags.
	▪	Profiling to find the 80/20.
	▪	Scaling as landscape grows.
	▪	Scaling as water/land ratio decreases.
	▪	Analysis and thought are what will get points, not raw data.
	▪	Document optimisation - do some dumb code first so we can optimise it easily?
	▪	Graphs of performance characteristics.

Validation of results:
	▪	(Polish) compare results with an analytical solution if we can come up with one.

(Polish) Coding standard:
	▪	Pick one and go with it.
	▪	Use astyle to apply it.

Report:
	▪	In version control so we can all add to it as we go.
	▪	David to show us all a little LaTeX?
	▪	Introduction.
	▪	Planning.
	▪	What who did.
	▪	Design.
	▪	How C++ was useful & how we used it.
	▪	How Git and GitHub were useful & how we used them.
	▪	Build tools.
	▪	Testing.
	▪	Debugging.
	▪	Performance testing & analysis.
	▪	Conclusions.
	▪	8-12 pages.

(Polish) Optimisation:

(Polish) User Interface:
	▪	Minimum is batch mode - what else could we do aside from a full-blown GUI?

