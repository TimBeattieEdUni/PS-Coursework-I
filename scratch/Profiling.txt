Profiling:

(redo timings - taking a lot longer now - did I take times from macbook?)

Profiling was done using gprof on cplab151 with an all-land 800x800 cell landscape for all runs of the program.  For reference an initial run of the program was done and was found to take 47.437 seconds.  Profiling the the first implementation of the popsim program revealed that three functions accounted for approximately 80% of the run time:

	Flat profile:

	Each sample counts as 0.01 seconds.
	%	cumulative	self			self	total	
	time	seconds		seconds	calls		s/call	s/call	name	
	47.00	58.77		58.77	1250		0.05	0.09	PsCourseworkI::Landscape::Update()
	24.30	89.15		30.38	4806406416	0.00	0.00	PsCourseworkI::Array2D<PsCourseworkI::Cell>::operator()(unsigned int, unsigned int)
	10.75	102.59		13.44	511439120	0.00	0.00	std::vector<PsCourseworkI::Cell, std::allocator<PsCourseworkI::Cell> >::operator[](unsigned long)

	(figure n: output from gprof on 800x800 all-land array on CP Lab)


The program spent more time in Landscape::Update() than any other function.  This was to be expected as all of the calculation was done there.  However, one quarter of the run time was spent accessing elements of the landscape array, and this allowed a simple modification which improved performance significantly: removal of the bounds checking on every element access in Array2D<T>::operator().  This change was made and the profiling run was redone, producing the following results:

	Flat profile:

	Each sample counts as 0.01 seconds.
	%	cumulative	self			self	total	
	time	seconds		seconds	calls		s/call	s/call	name	
	50.30	58.25		58.25	1250		0.05	0.09	PsCourseworkI::Landscape::Update()
	15.18	75.83		17.58	4806406416	0.00	0.00	PsCourseworkI::Array2D<PsCourseworkI::Cell>::operator()(unsigned int, unsigned int)
	13.72	91.71		15.89	511439120	0.00	0.00	std::vector<PsCourseworkI::Cell, std::allocator<PsCourseworkI::Cell> >::operator[](unsigned long)

	(figure n: output from gprof on 800x800 all-land array on CP Lab after removing bounds checking from Array2D<T>::operator())

Run time for this modified implementation was 27.123 seconds - an improvement of 43% over the implementation with bounds checking.  While bounds checking was included in the initial version of Array2D<T>::operator() as a precaution, once the program had been demonstrated to work correctly, the considerable performance improvement achieved by removing it was considered to be worthwhile.

Checking the documentation for class std::vector revealed that element access with bounds checking is provided by the function std::vector<T>::at().  Replacing std::vector<T>::operator[] with this function resulted in a run time of 35.127 seconds, an improvement of 26% over the initial implementation but still considerably slower than with no bounds checking at all.  All three possibilites were left in the code with the unused options commented out.

Another optimisation was considered: making every landscape cell store pointers to its neighbours to the north, south, east, and west, so that function Landscape::Update() could access a cell's neighbours with four fewer calls to Array2D::operator().  Neighbours would be stored during initialisation of the array, meaning the array accesses would be done just once instead of once per update.  However, there was insufficient time for this change to be implemented and tested.
