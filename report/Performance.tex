% Description of what testing you did and any test frameworks that were usedi
\section{Performance Tests and Analysis}
\label{Performance Tests and Analysis}

\subection{Profiling and optimisation}
\label{Profiling and optimisation}

Profiling runs were done on the CP Lab machines with an all-land 800x800 cell landscape for all runs of the program.  The CP Lab machines were chosen because of the availability of a working version of gprof, which was not present on all of the group's own computers. 
Timing runs were done on a faster machine: a core i7 laptop with a solid-state hard drive. 
This machine was chosen in order to save time as the CP Labs machines were considerably slower. 
It was assumed that since the program's work was primarily calculation and memory access that profiling would produce reliable results even if timings were done on a different machine.\\

For reference an initial run of the program was done and was found to take 47.437 seconds.  Profiling the first implementation of the popsim program revealed that three functions accounted for approximately 80\% of the run time, see tab.(\ref{tab: profile 1}).


\begin{table}
\caption{Output from gprof on 800x800 all-land array on CP Lab}
\label{tab: profile 1}
 \begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
name & time [\%] & time [s] & sef time [s] & calls\\
\hline
$Landscape::Update()$ & 47.00 & 58.77 & 58.77 & 1250\\
\hline
$Array2D::operator()$& 24.30 & 89.15 & 30.38& 4806406416\\
\hline
$std::vector::operator[]$& 10.75& 102.59 & 13.44 & 511439120\\
\hline
\end{tabular}
\end{center}
\end{table}


The program spent more time in $Landscape::Update()$ than any other function.
This was to be expected as all of the calculation was done there. However, one quarter of the run time was spent accessing elements of the landscape array, and this suggested a simple modification which improved performance significantly.
The removal of the bounds checking on every element access in $Array2D<T>::operator()$. This change was made and the profiling run was redone, producing the results presented in tab.(\ref{tab: profile 2}).

\begin{table}
\caption{second profile.}
\label{tab: profile 2}
 \begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
name & time [\%] & time [s] & sef time [s] & calls\\
\hline
$Landscape::Update()$ & 50.30 & 58.25 & 58.25 & 1250\\
\hline
$Array2D::operator()$& 15.18 & 75.83& 17.58 & 4806406416\\
\hline
$std::vector::operator[]$&13.72& 91.71 &15.89 & 511439120\\
\hline
\end{tabular}
\end{center}
\end{table}

Run time for this modified implementation was 27.123 seconds which means an improvement of 43\% over the implementation with bounds checking.
While bounds checking was included in the initial version of $Array2D<T>::operator()$ as a precaution, once the program had been demonstrated to work correctly, the considerable performance improvement achieved by removing it was considered to be worthwhile.\\
The reference documentation for class $std::vector$ states that element access with bounds checking is provided by the function $std::vector<T>::at()$.  A timing run was performed with $std::vector<T>::operator[]$ replaced with $std::vector<T>::at()$, resulting in a run time of 35.127 seconds.
This was an improvement of 26\% over the initial implementation but still considerably slower than with no bounds checking at all. 
All three options were left in the code in $Landscape::Update()$ with the unused options commented out.\\

A second optimisation became apparent on examination of the for loops in $Landscape::Update()$. The code was iterating over the x-coordinate of a cell, then over its y-coordinate.
While this was the intuitive order, it caused the code to stride through the array of cells by a distance proportional to the width of the landscape array instead of accessing the next cell in memory each time.
The order of the iterations was swapped, and another profiling and timing run were performed leading to output shown in tab.(\ref{ profile 3})


\begin{table}
\caption{second profile.}
\label{tab: profile 3}
 \begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
name & time [\%] & time [s] & sef time [s] & calls\\
\hline
$Landscape::Update()$ & 48.54 & 59.65 & 59.65 &1250 \\
\hline
$Array2D::operator()$& 17.45& 81.10& 21.45 &4806406416 \\
\hline
$std::vector::operator[]$& 12.34& 96.27 &15.17 &511439120\\
\hline
\end{tabular}
\end{center}
\end{table}

Run time with the order of iterations swapped was 12.366 seconds, a reduction of 54\% from the previous implementation and a reduction of 74\% from the original unoptimised implementation.\\

Finally, another optimisation was considered: making every landscape cell store pointers to its neighbours to the north, south, east, and west, so that function $Landscape::Update()$ could access each cell's neighbours without calling $Array2D::operator()$ four times.
Neighbours would be stored during initialisation of the array, meaning the array accesses would be done just once instead of once per update, reducing the number of memory accesses to non-local parts of the array.
However, there was insufficient time for this change to be implemented and tested.\\

It would also have been interesting to see if any difference in performance could be found between runs on landscapes with different arrangements of land and water due to branch prediction as the Landscape class verifies that cell is land before performing the calculation for that cell.
A landscape consisting entirely of islands of one cell would cause the branch prediction to be wrong most if not all of the time, which would presumably reduce performance compared to a landscape with the same number of land cells arranged at the top or bottom of the landscape, corresponding to the beginning or end of the landscape array.




\subection{Performance of the optimised code}
\label{performance of the optimied code}

TODO: add text 

\begin{table}
\caption{Timing for increasing landscape sizes}
\label{tab: Size timing}
 \begin{center}
\begin{tabular}{|c|c|c|}
\hline
Ladscape Size & run time [s] & delta run time[s]\\
\hline
200 & 1.8722 & Ã—\\
\hline
400 & 11.662 & 9.7898\\
\hline
600 & 25.526 & 13.864\\
\hline
800 & 48.755 & 23.229\\
\hline
1000 & 81.310 & 32.555\\
\hline
1200 & 97.364 & 16.054\\
\hline
1400 & 145.020 & 47.656\\
\hline
1600 & 220.000 & 74.98\\
\hline
1800 & 277.366 & 57.366\\
\hline
200 & 346.391 & 69.025\\
\hline
\end{tabular}
\end{center}
\end{table}




