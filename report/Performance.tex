% Description of what testing you did and any test frameworks that were usedi
\section{Performance Tests and Analysis}
\label{Performance Tests and Analysis}

Timing and profiling runs were performed on the CP Lab machines due to the availability of a working version of gprof, which was not present on all of the group's own computers.
Optimisation was performed in two stages: changes to the code, and changes to the compiler optimisation flags.  For the first stage the $-O3$ flag was used for all runs.  The second stage chose the best-performing version of the program from the first stage and observed the effects of compiling with the $-O4$ and $-O5$ flags.
Run time of the program was measured over a series of square landscapes with sizes ranging from 200x200 to 2000x2000.
Profiling runs were performed using an 800x800 landscape.
All timing runs were configured to perform 1250 time steps with PPM file output every 100 time steps.
Program speedup \textit{S} for subsequent runs was calculated with the following equation:

\begin{equation} 
S = T_{ref} / T 
\label{equation:speedup}
\end{equation}

...where $T_{ref}$  was the time taken by the initial reference run and ${T}$ was the time taken by the run for which speedup was being calculated.


PUT 1ST GRAPH HERE?


\subsection{Code optimisation}
\label{Code optimisation}

\begin{table}[h!]
\caption{Tabulated partial output from gprof on first profiled version of popsim.}
\label{tab:profile1}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
time [\%] & time [s] & self time [s] & calls & name\\
\hline
47.00 & 58.77 & 58.77 & 1250 & $Landscape::Update()$\\
\hline
24.30 & 89.15 & 30.38& 4806406416 & $Array2D::operator()$\\
\hline
10.75& 102.59 & 13.44 & 511439120 & $std::vector::operator[]$\\
\hline
\end{tabular}
\end{center}
\end{table}

Table \ref{tab:profile1} shows partial output from gprof for the initial version of the code.
Three functions accounted for approximately 82\% of the run time, with nearly half of the run time spent in $Landscape::Update()$.
This was to be expected as the bulk of the program's work was done in this function.
However, nearly one quarter of the run time was spent accessing elements of the landscape array, and this suggested a simple modification: removing the bounds checking on every element access in $Array2D<T>::operator()$. 
This change was made and a second timing run and profiling run were done.

\begin{table}[h!]
\caption{Tabulated partial output from gprof after array bounds checking removal.}
\label{tab:profile2}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
time [\%] & time [s] & sef time [s] & calls & name\\
\hline
50.30 & 58.25 & 58.25 & 1250 & $Landscape::Update()$\\
\hline
15.18 & 75.83 & 17.58 & 4806406416 & $Array2D::operator()$\\
\hline
13.72 & 91.71 & 15.89 & 511439120 & $std::vector::operator[]$\\
\hline
\end{tabular}
\end{center}
\end{table}

Table \ref{tab:profile2} shows partial output from gprof for the version of the code with array bounds removed.  
The time spent in $Array2D::operator()$ was significantly reduced compared to the first profiling run.  
While bounds checking was included in the initial version of $Array2D<T>::operator()$ for safety, once the program had been demonstrated to work correctly, the considerable performance improvement achieved by removing bounds checking was considered to be worthwhile.
The reference documentation for class $std::vector$ states that element access with bounds checking is provided by the function $std::vector<T>::at()$.
A timing run was performed with $std::vector<T>::operator[]$ replaced with $std::vector<T>::at()$, resulting in a run time of 45.721 seconds, representing a program speedup of 1.28.
This was an improvement but still considerably slower than with no bounds checking at all. 
All three options were left in the code in $Landscape::Update()$ with the unused options commented out.

A second optimisation became apparent on examination of the for loops in $Landscape::Update()$.
The code was iterating over the x-coordinate of a cell, then over its y-coordinate.
While this was the intuitive order, it caused the code to stride through the array of cells by a distance proportional to the width of the landscape array instead of accessing the next cell in memory each time.
The order of the iterations was swapped, and another profiling and timing run were performed.
Run time with the order of iterations swapped was 36.48 seconds, representing a program speedup of 1.60.

\begin{table}[h!]
\caption{Tabulated partial output from gprof after iteration order swap.}
\label{tab: profile 3}
 \begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
name & time [\%] & time [s] & sef time [s] & calls\\
\hline
$Landscape::Update()$ & 48.54 & 59.65 & 59.65 &1250 \\
\hline
$Array2D::operator()$& 17.45& 81.10& 21.45 &4806406416 \\
\hline
$std::vector::operator[]$& 12.34& 96.27 &15.17 &511439120\\
\hline
\end{tabular}
\end{center}
\end{table}

Table \ref{tab:profile3} shows partial output from gprof for the version of the code with array bounds removed and with iteration order reversed.
This version spent a slightly lower percentage of its run time in function Landscape::Update().
The improvement in performance was less than expected given that memory loading into cache was theoretically optimised.

A further optimisation was considered but not implemented due to time constraints: storing pointers to cell neighbours in each cell so that function $Landscape::Update()$ could access each cell's neighbours without calling $Array2D::operator()$ four times.
These pointers would be initialised at program startup meaning the array accesses would be done just once instead of once per update and reducing the number of memory accesses to non-local parts of the array.
However, there was insufficient time for this change to be implemented and tested.\\

The group also considered checking whether any difference in performance could be found between runs on landscapes with different arrangements of land and water due to branch prediction as the Landscape class verifies that cell is land before performing the calculation for that cell.
A landscape consisting entirely of islands of one cell would presumably cause the branch prediction to be wrong most if not all of the time, which would presumably reduce performance compared to a landscape with the same number of land cells arranged at the top or bottom of the landscape, corresponding to the beginning or end of the landscape array.


\subsection{Compiler optimisation.}
\label{Compiler optimisation}

With array bounds checking removed and iteration order swapped, two more versions of the program were built with the compiler optimisation flag set to $-O4$ and $-O5$.
Timing runs were then performed and are compared to the version compiled with $-O3$ in graph REFERENCE HERE.

It was found that the various compiler optimisation flags made only a slight improvement for some landscape sizes and actually reduced performance in some cases.


\begin{table}
\caption{Timing for increasing landscape sizes}
\label{tab: Size timing}
 \begin{center}
\begin{tabular}{|c|c|c|}
\hline
Ladscape Size & run time [s] & delta run time[s]\\
\hline
200 & 1.8722 & Ã—\\
\hline
400 & 11.662 & 9.7898\\
\hline
600 & 25.526 & 13.864\\
\hline
800 & 48.755 & 23.229\\
\hline
1000 & 81.310 & 32.555\\
\hline
1200 & 97.364 & 16.054\\
\hline
1400 & 145.020 & 47.656\\
\hline
1600 & 220.000 & 74.98\\
\hline
1800 & 277.366 & 57.366\\
\hline
200 & 346.391 & 69.025\\
\hline
\end{tabular}
\end{center}
\end{table}




